docker-compose up -d
docker exec -it nestjs_api_postgres psql -U admin_tpi  -d nest_api_db
\dt
\q
docker volume rm postgres_data
docker volume ls
docker ps
docker-compose down --volumes

npm run migration:generate
npm run migration:run
npm run create:admin
nest start

como quedarian los service modificados tomando en cuenta que estan asi:

// src/province/province.service.ts

import { Injectable, NotFoundException, ConflictException, Logger, BadRequestException } from '@nestjs/common';

import { InjectRepository } from '@nestjs/typeorm';

import { Repository, ILike, Not } from 'typeorm';

import { Province } from './entities/province.entity';

import { Country } from '../country/entities/country.entity';

import { CreateProvinceDto } from './dto/create-province.dto';

import { UpdateProvinceDto } from './dto/update-patch-province.dto';

import { UpdatePutProvinceDto } from './dto/update-put-province.dto';



@Injectable()

export class ProvincesService {

  private readonly logger = new Logger(ProvincesService.name);



  constructor(

    @InjectRepository(Province)

    private readonly provinceRepository: Repository<Province>,

    @InjectRepository(Country)

    private readonly countryRepository: Repository<Country>,

  ) {}



  private readonly defaultRelations = ['country', 'cities'];



  private async findCountryById(countryId: number): Promise<Country> {

    this.logger.debug(`Buscando país ID: ${countryId}`);

    const country = await this.countryRepository.findOne({ where: { id: countryId } });

    if (!country) {

      this.logger.warn(`País ID ${countryId} no encontrado.`);

      throw new NotFoundException(`País con ID ${countryId} no encontrado.`);

    }

    return country;

  }



  async create(createProvinceDto: CreateProvinceDto): Promise<Province> {

    this.logger.debug(`Creando provincia: ${createProvinceDto.name}, Lat: ${createProvinceDto.latitude}, Lon: ${createProvinceDto.longitude}`);

    const country = await this.findCountryById(createProvinceDto.countryId);



    const existingByCoords = await this.provinceRepository.findOne({

      where: { latitude: createProvinceDto.latitude, longitude: createProvinceDto.longitude }

    });

    if (existingByCoords) {

      this.logger.log(`Provincia en Lat: ${createProvinceDto.latitude}, Lon: ${createProvinceDto.longitude} (Nombre: ${existingByCoords.name}) ya existe. Retornando existente.`);

      return this.findOne(existingByCoords.id, true);

    }



    const existingNominal = await this.provinceRepository.findOne({

        where: { name: createProvinceDto.name, countryId: createProvinceDto.countryId }

    });

    if (existingNominal) {

        this.logger.warn(`Conflicto nominal: Provincia '${createProvinceDto.name}' ya existe en país '${country.name}' (coords difieren).`);

    }



    const province = this.provinceRepository.create({

      name: createProvinceDto.name,

      country,

      countryId: country.id,

      latitude: createProvinceDto.latitude,

      longitude: createProvinceDto.longitude,

    });



    try {

        const savedProvince = await this.provinceRepository.save(province);

        this.logger.log(`Provincia '${savedProvince.name}' creada ID: ${savedProvince.id}`);

        return this.findOne(savedProvince.id, true);

    } catch (error: any) {

        if (error.code === '23505') {

            this.logger.warn(`Conflicto BD al guardar provincia: ${error.detail}. Buscando de nuevo...`);

            const raceCondition = await this.provinceRepository.findOne({

                where: { latitude: createProvinceDto.latitude, longitude: createProvinceDto.longitude }

            });

            if (raceCondition) return this.findOne(raceCondition.id, true);

            throw new ConflictException(`Ubicación (lat/lon) para esta provincia ya existe.`);

        }

        this.logger.error(`Error al guardar provincia: ${error.message}`, error.stack);

        throw error;

    }

  }



  async findAll(loadRelations: boolean = true): Promise<Province[]> {

    this.logger.debug('Buscando todas las provincias');

    return this.provinceRepository.find({ relations: loadRelations ? this.defaultRelations : ['country'] });

  }



  async findOne(id: number, loadRelations: boolean = true): Promise<Province> {

    this.logger.debug(`Buscando provincia ID: ${id}`);

    const province = await this.provinceRepository.findOne({

      where: { id },

      relations: loadRelations ? this.defaultRelations : ['country'],

    });

    if (!province) {

      this.logger.warn(`Provincia ID ${id} no encontrada.`);

      throw new NotFoundException(`Provincia con ID ${id} no encontrada.`);

    }

    return province;

  }



  async findOneByNameAndCountryId(name: string, countryId: number, loadRelations: boolean = false): Promise<Province | null> {

    this.logger.debug(`Buscando provincia: ${name}, país ID: ${countryId}`);

    return this.provinceRepository.findOne({

      where: { name, countryId },

      relations: loadRelations ? this.defaultRelations : ['country'],

    });

  }



  async searchByName(term: string, loadRelations: boolean = false): Promise<Province[]> {

    this.logger.debug(`Buscando provincias por término: ${term}`);

    if (!term || term.trim() === "") {

      throw new BadRequestException('Término de búsqueda vacío.');

    }

    return this.provinceRepository.find({

      where: { name: ILike(`%${term}%`) },

      relations: loadRelations ? this.defaultRelations : ['country'],

    });

  }



  async updatePut(id: number, updateDto: UpdatePutProvinceDto): Promise<Province> {

    this.logger.debug(`Actualizando (PUT) provincia ID: ${id}`);

    const provinceToUpdate = await this.findOne(id, false);

    const country = await this.findCountryById(updateDto.countryId);



    if (updateDto.latitude !== provinceToUpdate.latitude || updateDto.longitude !== provinceToUpdate.longitude) {

        const existing = await this.provinceRepository.findOne({

            where: { latitude: updateDto.latitude, longitude: updateDto.longitude, id: Not(id) }

        });

        if (existing) throw new ConflictException(`Ubicación (lat/lon) ya registrada para otra provincia.`);

    }

    if (updateDto.name !== provinceToUpdate.name || updateDto.countryId !== provinceToUpdate.countryId) {

        const existing = await this.provinceRepository.findOne({

            where: { name: updateDto.name, countryId: updateDto.countryId, id: Not(id) }

        });

        if (existing) throw new ConflictException(`Provincia '${updateDto.name}' ya existe en el país.`);

    }



    provinceToUpdate.name = updateDto.name;

    provinceToUpdate.country = country;

    provinceToUpdate.countryId = country.id;

    provinceToUpdate.latitude = updateDto.latitude;

    provinceToUpdate.longitude = updateDto.longitude;



    const updated = await this.provinceRepository.save(provinceToUpdate);

    this.logger.log(`Provincia ID ${updated.id} actualizada (PUT).`);

    return this.findOne(updated.id, true);

  }



  async updatePatch(id: number, updateDto: UpdateProvinceDto): Promise<Province> {

    this.logger.debug(`Actualizando (PATCH) provincia ID: ${id}`);

    const provinceToUpdate = await this.provinceRepository.findOne({ where: {id}, relations: ['country'] });

    if (!provinceToUpdate) {

      this.logger.warn(`Provincia ID ${id} no encontrada para PATCH.`);

      throw new NotFoundException(`Provincia con ID ${id} no encontrada.`);

    }



    let nameChanged = false, countryChanged = false, coordsChanged = false;

    if (updateDto.name !== undefined) { provinceToUpdate.name = updateDto.name; nameChanged = true; }

    if (updateDto.countryId !== undefined && provinceToUpdate.countryId !== updateDto.countryId) {

      const country = await this.findCountryById(updateDto.countryId);

      provinceToUpdate.country = country;

      provinceToUpdate.countryId = country.id;

      countryChanged = true;

    }

    if (updateDto.latitude !== undefined) { provinceToUpdate.latitude = updateDto.latitude; coordsChanged = true; }

    if (updateDto.longitude !== undefined) { provinceToUpdate.longitude = updateDto.longitude; coordsChanged = true; }



    if (coordsChanged) {

        const existing = await this.provinceRepository.findOne({

            where: { latitude: provinceToUpdate.latitude, longitude: provinceToUpdate.longitude, id: Not(id) }

        });

        if (existing) throw new ConflictException(`Ubicación (lat/lon) ya registrada para otra provincia.`);

    }

    if ((nameChanged || countryChanged) && !coordsChanged) {

        const existing = await this.provinceRepository.findOne({

            where: { name: provinceToUpdate.name, countryId: provinceToUpdate.countryId, id: Not(id) }

        });

        if (existing) throw new ConflictException(`Provincia '${provinceToUpdate.name}' ya existe en el país.`);

    }

    // georefId eliminado



    const updated = await this.provinceRepository.save(provinceToUpdate);

    this.logger.log(`Provincia ID ${updated.id} actualizada (PATCH).`);

    return this.findOne(updated.id, true);

  }



  async remove(id: number): Promise<{ message: string }> {

    this.logger.debug(`Eliminando provincia ID: ${id}`);

    const province = await this.findOne(id, true);

    if (province.cities && province.cities.length > 0) {

      this.logger.warn(`No se puede eliminar provincia ID ${id}, tiene ciudades asociadas.`);

      throw new ConflictException(`No se puede eliminar provincia '${province.name}', tiene ciudades asociadas.`);

    }

    await this.provinceRepository.remove(province);

    this.logger.log(`Provincia ID: ${id} eliminada.`);

    return { message: `Provincia con ID ${id} eliminada correctamente.` };

  }

}

// src/city/city.service.ts

import { Injectable, NotFoundException, Logger, ConflictException, BadRequestException } from '@nestjs/common';

import { InjectRepository } from '@nestjs/typeorm';

import { Repository, ILike, Not, FindOptionsWhere } from 'typeorm'; // Importar FindOptionsWhere

import { City } from './entities/city.entity';

import { Province } from '../province/entities/province.entity';

import { CreateCityDto } from './dto/create-city.dto';

import { UpdateCityDto } from './dto/update-patch-city.dto';

import { UpdatePutCityDto } from './dto/update-put-city.dto';



@Injectable()

export class CitiesService {

  private readonly logger = new Logger(CitiesService.name);



  constructor(

    @InjectRepository(City)

    private readonly cityRepository: Repository<City>,

    @InjectRepository(Province)

    private readonly provinceRepository: Repository<Province>,

  ) {}



  private readonly defaultRelations = ['province', 'province.country'];



  private async findProvinceById(provinceId: number): Promise<Province> {

    this.logger.debug(`Buscando provincia ID: ${provinceId}`);

    const province = await this.provinceRepository.findOne({

        where: { id: provinceId },

        relations: ['country'],

      });

    if (!province) {

      this.logger.warn(`Provincia ID ${provinceId} no encontrada.`);

      throw new NotFoundException(`Provincia con ID ${provinceId} no encontrada.`);

    }

    return province;

  }



  async create(createCityDto: CreateCityDto): Promise<City> {

    this.logger.debug(`Intentando crear ciudad: ${createCityDto.name}, Lat: ${createCityDto.latitude}, Lon: ${createCityDto.longitude}`);

    const province = await this.findProvinceById(createCityDto.provinceId);



    const existingCityByCoords = await this.cityRepository.findOne({

      where: {

        latitude: createCityDto.latitude,

        longitude: createCityDto.longitude,

      }

    });



    if (existingCityByCoords) {

      this.logger.log(`Ciudad en Lat: ${createCityDto.latitude}, Lon: ${createCityDto.longitude} (Nombre: ${existingCityByCoords.name}) ya existe. Se omite creación y se retorna la existente.`);

      return this.findOne(existingCityByCoords.id, true);

    }



    const existingNominalCity = await this.cityRepository.findOne({

        where: { name: createCityDto.name, provinceId: createCityDto.provinceId }

    });

    if (existingNominalCity) {

        this.logger.warn(`Conflicto nominal: La ciudad '${createCityDto.name}' ya existe en la provincia '${province.name}' (pero con diferentes coordenadas).`);

        // throw new ConflictException(`Una ciudad llamada '${createCityDto.name}' ya existe en la provincia '${province.name}'.`);

    }



    const city = this.cityRepository.create({

      name: createCityDto.name,

      province: province,

      provinceId: province.id,

      latitude: createCityDto.latitude,

      longitude: createCityDto.longitude,

      // georefId: createCityDto.georefId || null, // georefId eliminado

    });



    try {

        const savedCity = await this.cityRepository.save(city);

        this.logger.log(`Ciudad creada ID: ${savedCity.id}, Nombre: ${savedCity.name}, Lat: ${savedCity.latitude}, Lon: ${savedCity.longitude}`);

        return this.findOne(savedCity.id, true);

    } catch (error: any) {

        if (error.code === '23505') {

            this.logger.warn(`Conflicto de BD al guardar ciudad: ${error.detail}. Intentando encontrarla...`);

            const raceConditionCity = await this.cityRepository.findOne({

                where: { latitude: createCityDto.latitude, longitude: createCityDto.longitude }

            });

            if (raceConditionCity) return this.findOne(raceConditionCity.id, true);

            throw new ConflictException(`La ubicación (lat/lon) para esta ciudad ya existe.`);

        }

        this.logger.error(`Error al guardar la ciudad: ${error.message}`, error.stack);

        throw error;

    }

  }



  async findAll(): Promise<City[]> {

    this.logger.debug('Buscando todas las ciudades');

    return this.cityRepository.find({ relations: this.defaultRelations });

  }



  async findOne(id: number, loadRelations: boolean = true): Promise<City> {

    this.logger.debug(`Buscando ciudad ID: ${id}`);

    const city = await this.cityRepository.findOne({

      where: { id },

      relations: loadRelations ? this.defaultRelations : ['province'],

    });

    if (!city) {

      this.logger.warn(`Ciudad ID ${id} no encontrada.`);

      throw new NotFoundException(`Ciudad con ID ${id} no encontrada.`);

    }

    return city;

  }



  async searchByName(term: string): Promise<City[]> {

    this.logger.debug(`Buscando ciudades por término: ${term}`);

    if (!term || term.trim() === "") {

      throw new BadRequestException('El término de búsqueda no puede estar vacío.');

    }

    const cities = await this.cityRepository.find({

      where: {

        name: ILike(`%${term}%`),

      },

      relations: this.defaultRelations,

    });

    this.logger.log(`Encontradas ${cities.length} ciudades para el término: ${term}`);

    return cities;

  }



  async findOneByNameAndProvinceName(cityName: string, provinceName: string): Promise<City | null> {

    this.logger.debug(`Buscando ciudad por nombre '${cityName}'${provinceName ? ` en provincia '${provinceName}'` : ''}`);

    

    const queryOptions: FindOptionsWhere<City> | FindOptionsWhere<City>[] = {

        name: cityName, // Búsqueda exacta por nombre de ciudad

    };



    if (provinceName) {

      // Si se proporciona provinceName, necesitamos hacer un join o una subconsulta.

      // La forma más directa con TypeORM es filtrar por la relación.

      return this.cityRepository.findOne({

        where: {

            name: cityName,

            province: { // Filtrar por el nombre de la provincia relacionada

                name: provinceName,

            }

        },

        relations: ['province'], // Cargar la provincia para asegurar el filtro y para la respuesta

      });

    } else {

      // Si no se proporciona provinceName, buscar solo por nombre de ciudad.

      // Esto podría devolver múltiples resultados si varias provincias tienen una ciudad con ese nombre.

      // findOne devolverá la primera que encuentre. Si necesitas manejar múltiples, usa find.

      const cities = await this.cityRepository.find({

        where: queryOptions,

        relations: ['province'], // Cargar provincia para dar más contexto

      });

      if (cities.length > 1) {

        this.logger.warn(`Múltiples ciudades encontradas con el nombre '${cityName}'. Se recomienda especificar la provincia.`);

        // Podrías lanzar un error aquí o devolver la primera. Por ahora, devolvemos la primera.

        return cities[0];

      }

      return cities.length > 0 ? cities[0] : null;

    }

  }





  async findOneByNameAndProvinceId(name: string, provinceId: number, loadRelations: boolean = false): Promise<City | null> {

    this.logger.debug(`Buscando ciudad por nombre '${name}' y provinceId '${provinceId}'`);

    const city = await this.cityRepository.findOne({

        where: {

            name: name,

            provinceId: provinceId

        },

        relations: loadRelations ? this.defaultRelations : ['province'],

    });



    if (!city) {

        this.logger.log(`Ciudad con nombre '${name}' y provinceId '${provinceId}' no encontrada.`);

        return null;

    }

    return city;

  }



  async updatePut(id: number, updateDto: UpdatePutCityDto): Promise<City> {

    this.logger.debug(`Actualizando (PUT) ciudad ID: ${id}`);

    const cityToUpdate = await this.findOne(id, false);

    const province = await this.findProvinceById(updateDto.provinceId);



    if (updateDto.latitude !== cityToUpdate.latitude || updateDto.longitude !== cityToUpdate.longitude) {

        const existingByCoords = await this.cityRepository.findOne({

            where: { latitude: updateDto.latitude, longitude: updateDto.longitude, id: Not(id) }

        });

        if (existingByCoords) {

            throw new ConflictException(`La ubicación (latitud/longitud) ya está registrada para otra ciudad.`);

        }

    }

    if (updateDto.name !== cityToUpdate.name || updateDto.provinceId !== cityToUpdate.provinceId) {

        const existingNominal = await this.cityRepository.findOne({

            where: { name: updateDto.name, provinceId: updateDto.provinceId, id: Not(id) }

        });

        if (existingNominal) {

            throw new ConflictException(`La combinación de nombre '${updateDto.name}' y provincia ya existe para otra ciudad.`);

        }

    }



    cityToUpdate.name = updateDto.name;

    cityToUpdate.province = province;

    cityToUpdate.provinceId = province.id;

    cityToUpdate.latitude = updateDto.latitude;

    cityToUpdate.longitude = updateDto.longitude;



    const updatedCity = await this.cityRepository.save(cityToUpdate);

    this.logger.log(`Ciudad ID ${updatedCity.id} actualizada (PUT).`);

    return this.findOne(updatedCity.id, true);

  }



  async updatePatch(id: number, updateDto: UpdateCityDto): Promise<City> {

    this.logger.debug(`Actualizando (PATCH) ciudad ID: ${id}`);

    const cityToUpdate = await this.cityRepository.findOne({ where: {id}, relations: ['province']});



    if (!cityToUpdate) {

      this.logger.warn(`Ciudad ID ${id} no encontrada para PATCH.`);

      throw new NotFoundException(`Ciudad con ID ${id} no encontrada.`);

    }



    let nameChanged = false;

    if (updateDto.name !== undefined && updateDto.name !== cityToUpdate.name) {

        cityToUpdate.name = updateDto.name;

        nameChanged = true;

    }

    let provinceChanged = false;

    if (updateDto.provinceId !== undefined && cityToUpdate.provinceId !== updateDto.provinceId) {

      const province = await this.findProvinceById(updateDto.provinceId);

      cityToUpdate.province = province;

      cityToUpdate.provinceId = province.id;

      provinceChanged = true;

    }

    let coordsChanged = false;

    if (updateDto.latitude !== undefined && updateDto.latitude !== cityToUpdate.latitude) {

        cityToUpdate.latitude = updateDto.latitude;

        coordsChanged = true;

    }

    if (updateDto.longitude !== undefined && updateDto.longitude !== cityToUpdate.longitude) {

        cityToUpdate.longitude = updateDto.longitude;

        coordsChanged = true;

    }



    if (coordsChanged) {

        const existingByCoords = await this.cityRepository.findOne({

            where: { latitude: cityToUpdate.latitude, longitude: cityToUpdate.longitude, id: Not(id) }

        });

        if (existingByCoords) {

            throw new ConflictException(`La ubicación (latitud/longitud) ya está registrada para otra ciudad.`);

        }

    }

    if ((nameChanged || provinceChanged) && !coordsChanged) {

        const existingNominal = await this.cityRepository.findOne({

            where: { name: cityToUpdate.name, provinceId: cityToUpdate.provinceId, id: Not(id) }

        });

        if (existingNominal) {

            throw new ConflictException(`La combinación de nombre '${cityToUpdate.name}' y provincia ya existe para otra ciudad.`);

        }

    }



    const updatedCity = await this.cityRepository.save(cityToUpdate);

    this.logger.log(`Ciudad ID ${updatedCity.id} actualizada (PATCH).`);

    return this.findOne(updatedCity.id, true);

  }



  async remove(id: number): Promise<{ message: string }> {

    this.logger.debug(`Eliminando ciudad ID: ${id}`);

    const city = await this.findOne(id, true);

    if (city.persons && city.persons.length > 0) {

        this.logger.warn(`No se puede eliminar la ciudad ID ${id} porque tiene personas asociadas.`);

        throw new ConflictException(`No se puede eliminar la ciudad '${city.name}' porque tiene personas asociadas. Reasigne las personas primero.`);

    }

    await this.cityRepository.remove(city);

    this.logger.log(`Ciudad ID: ${id} eliminada.`);

    return { message: `Ciudad con ID ${id} eliminada correctamente.` };

  }

}

// src/country/country.service.ts

import { Injectable, NotFoundException, ConflictException, Logger, BadRequestException } from '@nestjs/common';

import { InjectRepository } from '@nestjs/typeorm';

import { Repository, ILike, Not } from 'typeorm';

import { Country } from './entities/country.entity';

import { CreateCountryDto } from './dto/create-country.dto';

import { UpdateCountryDto } from './dto/update-patch-country.dto';

import { UpdatePutCountryDto } from './dto/update-put-country.dto';



@Injectable()

export class CountriesService {

  private readonly logger = new Logger(CountriesService.name);



  constructor(

    @InjectRepository(Country)

    private readonly countryRepository: Repository<Country>,

  ) {}



  private readonly defaultRelations = ['provinces'];



  async create(createCountryDto: CreateCountryDto): Promise<Country> {

    this.logger.debug(`Creando país: ${createCountryDto.name}`);

    const { name, code } = createCountryDto;



    const existingByName = await this.countryRepository.findOne({ where: { name } });

    if (existingByName) {

      this.logger.warn(`País con nombre '${name}' ya existe.`);

      throw new ConflictException(`País con nombre '${name}' ya existe.`);

    }

    if (code) {

      const existingByCode = await this.countryRepository.findOne({ where: { code } });

      if (existingByCode) {

        this.logger.warn(`País con código '${code}' ya existe.`);

        throw new ConflictException(`País con código '${code}' ya existe.`);

      }

    }



    const country = this.countryRepository.create({ name, code });

    const savedCountry = await this.countryRepository.save(country);

    this.logger.log(`País creado ID: ${savedCountry.id}`);

    return savedCountry; // Devolver la entidad sin cargar relaciones por defecto al crear

  }



  async findAll(loadRelations: boolean = false): Promise<Country[]> {

    this.logger.debug('Buscando todos los países');

    return this.countryRepository.find({ relations: loadRelations ? this.defaultRelations : [] });

  }



  async findOne(id: number, loadRelations: boolean = false): Promise<Country> {

    this.logger.debug(`Buscando país ID: ${id}`);

    const country = await this.countryRepository.findOne({

      where: { id },

      relations: loadRelations ? this.defaultRelations : [],

    });

    if (!country) {

      this.logger.warn(`País ID ${id} no encontrado.`);

      throw new NotFoundException(`País con ID ${id} no encontrado.`);

    }

    return country;

  }



  async findOneByName(name: string, loadRelations: boolean = false): Promise<Country | null> {

    this.logger.debug(`Buscando país por nombre: ${name}`);

    return this.countryRepository.findOne({

      where: { name },

      relations: loadRelations ? this.defaultRelations : [],

    });

  }



  async searchByName(term: string, loadRelations: boolean = false): Promise<Country[]> {

    this.logger.debug(`Buscando países por término: ${term}`);

    if (!term || term.trim() === "") {

      throw new BadRequestException('El término de búsqueda no puede estar vacío.');

    }

    return this.countryRepository.find({

      where: { name: ILike(`%${term}%`) },

      relations: loadRelations ? this.defaultRelations : [],

    });

  }



  async updatePut(id: number, updateDto: UpdatePutCountryDto): Promise<Country> {

    this.logger.debug(`Actualizando (PUT) país ID: ${id}`);

    const countryToUpdate = await this.findOne(id, false);

    const { name, code } = updateDto;



    if (name !== countryToUpdate.name) {

      const existing = await this.countryRepository.findOne({ where: { name, id: Not(id) } });

      if (existing) throw new ConflictException(`País con nombre '${name}' ya existe.`);

    }

    if (code && code !== countryToUpdate.code) {

      const existing = await this.countryRepository.findOne({ where: { code, id: Not(id) } });

      if (existing) throw new ConflictException(`País con código '${code}' ya existe.`);

    }



    countryToUpdate.name = name;

    countryToUpdate.code = code === undefined ? countryToUpdate.code : code;



    const updatedCountry = await this.countryRepository.save(countryToUpdate);

    this.logger.log(`País ID ${updatedCountry.id} actualizado (PUT).`);

    return updatedCountry;

  }



  async updatePatch(id: number, updateDto: UpdateCountryDto): Promise<Country> {

    this.logger.debug(`Actualizando (PATCH) país ID: ${id}`);

    const countryToUpdate = await this.countryRepository.preload({ id, ...updateDto });

    if (!countryToUpdate) {

      this.logger.warn(`País ID ${id} no encontrado para PATCH.`);

      throw new NotFoundException(`País con ID ${id} no encontrado.`);

    }



    if (updateDto.name && updateDto.name !== countryToUpdate.name) {

      const existing = await this.countryRepository.findOne({ where: { name: updateDto.name, id: Not(id) } });

      if (existing) throw new ConflictException(`País con nombre '${updateDto.name}' ya existe.`);

    }

    if (updateDto.code && updateDto.code !== countryToUpdate.code) {

      const existing = await this.countryRepository.findOne({ where: { code: updateDto.code, id: Not(id) } });

      if (existing) throw new ConflictException(`País con código '${updateDto.code}' ya existe.`);

    }



    const updatedCountry = await this.countryRepository.save(countryToUpdate);

    this.logger.log(`País ID ${updatedCountry.id} actualizado (PATCH).`);

    return updatedCountry;

  }



  async remove(id: number): Promise<{ message: string }> {

    this.logger.debug(`Eliminando país ID: ${id}`);

    const country = await this.findOne(id, true); // Cargar provincias para verificar

    if (country.provinces && country.provinces.length > 0) {

      this.logger.warn(`No se puede eliminar país ID ${id}, tiene provincias asociadas.`);

      throw new ConflictException(`No se puede eliminar el país '${country.name}' porque tiene provincias asociadas.`);

    }

    await this.countryRepository.remove(country);

    this.logger.log(`País ID: ${id} eliminado.`);

    return { message: `País con ID ${id} eliminado correctamente.` };

  }

}como quedarian los service modificados tomando en cuenta que estan asi:

// src/province/province.service.ts

import { Injectable, NotFoundException, ConflictException, Logger, BadRequestException } from '@nestjs/common';

import { InjectRepository } from '@nestjs/typeorm';

import { Repository, ILike, Not } from 'typeorm';

import { Province } from './entities/province.entity';

import { Country } from '../country/entities/country.entity';

import { CreateProvinceDto } from './dto/create-province.dto';

import { UpdateProvinceDto } from './dto/update-patch-province.dto';

import { UpdatePutProvinceDto } from './dto/update-put-province.dto';



@Injectable()

export class ProvincesService {

  private readonly logger = new Logger(ProvincesService.name);



  constructor(

    @InjectRepository(Province)

    private readonly provinceRepository: Repository<Province>,

    @InjectRepository(Country)

    private readonly countryRepository: Repository<Country>,

  ) {}



  private readonly defaultRelations = ['country', 'cities'];



  private async findCountryById(countryId: number): Promise<Country> {

    this.logger.debug(`Buscando país ID: ${countryId}`);

    const country = await this.countryRepository.findOne({ where: { id: countryId } });

    if (!country) {

      this.logger.warn(`País ID ${countryId} no encontrado.`);

      throw new NotFoundException(`País con ID ${countryId} no encontrado.`);

    }

    return country;

  }



  async create(createProvinceDto: CreateProvinceDto): Promise<Province> {

    this.logger.debug(`Creando provincia: ${createProvinceDto.name}, Lat: ${createProvinceDto.latitude}, Lon: ${createProvinceDto.longitude}`);

    const country = await this.findCountryById(createProvinceDto.countryId);



    const existingByCoords = await this.provinceRepository.findOne({

      where: { latitude: createProvinceDto.latitude, longitude: createProvinceDto.longitude }

    });

    if (existingByCoords) {

      this.logger.log(`Provincia en Lat: ${createProvinceDto.latitude}, Lon: ${createProvinceDto.longitude} (Nombre: ${existingByCoords.name}) ya existe. Retornando existente.`);

      return this.findOne(existingByCoords.id, true);

    }



    const existingNominal = await this.provinceRepository.findOne({

        where: { name: createProvinceDto.name, countryId: createProvinceDto.countryId }

    });

    if (existingNominal) {

        this.logger.warn(`Conflicto nominal: Provincia '${createProvinceDto.name}' ya existe en país '${country.name}' (coords difieren).`);

    }



    const province = this.provinceRepository.create({

      name: createProvinceDto.name,

      country,

      countryId: country.id,

      latitude: createProvinceDto.latitude,

      longitude: createProvinceDto.longitude,

    });



    try {

        const savedProvince = await this.provinceRepository.save(province);

        this.logger.log(`Provincia '${savedProvince.name}' creada ID: ${savedProvince.id}`);

        return this.findOne(savedProvince.id, true);

    } catch (error: any) {

        if (error.code === '23505') {

            this.logger.warn(`Conflicto BD al guardar provincia: ${error.detail}. Buscando de nuevo...`);

            const raceCondition = await this.provinceRepository.findOne({

                where: { latitude: createProvinceDto.latitude, longitude: createProvinceDto.longitude }

            });

            if (raceCondition) return this.findOne(raceCondition.id, true);

            throw new ConflictException(`Ubicación (lat/lon) para esta provincia ya existe.`);

        }

        this.logger.error(`Error al guardar provincia: ${error.message}`, error.stack);

        throw error;

    }

  }



  async findAll(loadRelations: boolean = true): Promise<Province[]> {

    this.logger.debug('Buscando todas las provincias');

    return this.provinceRepository.find({ relations: loadRelations ? this.defaultRelations : ['country'] });

  }



  async findOne(id: number, loadRelations: boolean = true): Promise<Province> {

    this.logger.debug(`Buscando provincia ID: ${id}`);

    const province = await this.provinceRepository.findOne({

      where: { id },

      relations: loadRelations ? this.defaultRelations : ['country'],

    });

    if (!province) {

      this.logger.warn(`Provincia ID ${id} no encontrada.`);

      throw new NotFoundException(`Provincia con ID ${id} no encontrada.`);

    }

    return province;

  }



  async findOneByNameAndCountryId(name: string, countryId: number, loadRelations: boolean = false): Promise<Province | null> {

    this.logger.debug(`Buscando provincia: ${name}, país ID: ${countryId}`);

    return this.provinceRepository.findOne({

      where: { name, countryId },

      relations: loadRelations ? this.defaultRelations : ['country'],

    });

  }



  async searchByName(term: string, loadRelations: boolean = false): Promise<Province[]> {

    this.logger.debug(`Buscando provincias por término: ${term}`);

    if (!term || term.trim() === "") {

      throw new BadRequestException('Término de búsqueda vacío.');

    }

    return this.provinceRepository.find({

      where: { name: ILike(`%${term}%`) },

      relations: loadRelations ? this.defaultRelations : ['country'],

    });

  }



  async updatePut(id: number, updateDto: UpdatePutProvinceDto): Promise<Province> {

    this.logger.debug(`Actualizando (PUT) provincia ID: ${id}`);

    const provinceToUpdate = await this.findOne(id, false);

    const country = await this.findCountryById(updateDto.countryId);



    if (updateDto.latitude !== provinceToUpdate.latitude || updateDto.longitude !== provinceToUpdate.longitude) {

        const existing = await this.provinceRepository.findOne({

            where: { latitude: updateDto.latitude, longitude: updateDto.longitude, id: Not(id) }

        });

        if (existing) throw new ConflictException(`Ubicación (lat/lon) ya registrada para otra provincia.`);

    }

    if (updateDto.name !== provinceToUpdate.name || updateDto.countryId !== provinceToUpdate.countryId) {

        const existing = await this.provinceRepository.findOne({

            where: { name: updateDto.name, countryId: updateDto.countryId, id: Not(id) }

        });

        if (existing) throw new ConflictException(`Provincia '${updateDto.name}' ya existe en el país.`);

    }



    provinceToUpdate.name = updateDto.name;

    provinceToUpdate.country = country;

    provinceToUpdate.countryId = country.id;

    provinceToUpdate.latitude = updateDto.latitude;

    provinceToUpdate.longitude = updateDto.longitude;



    const updated = await this.provinceRepository.save(provinceToUpdate);

    this.logger.log(`Provincia ID ${updated.id} actualizada (PUT).`);

    return this.findOne(updated.id, true);

  }



  async updatePatch(id: number, updateDto: UpdateProvinceDto): Promise<Province> {

    this.logger.debug(`Actualizando (PATCH) provincia ID: ${id}`);

    const provinceToUpdate = await this.provinceRepository.findOne({ where: {id}, relations: ['country'] });

    if (!provinceToUpdate) {

      this.logger.warn(`Provincia ID ${id} no encontrada para PATCH.`);

      throw new NotFoundException(`Provincia con ID ${id} no encontrada.`);

    }



    let nameChanged = false, countryChanged = false, coordsChanged = false;

    if (updateDto.name !== undefined) { provinceToUpdate.name = updateDto.name; nameChanged = true; }

    if (updateDto.countryId !== undefined && provinceToUpdate.countryId !== updateDto.countryId) {

      const country = await this.findCountryById(updateDto.countryId);

      provinceToUpdate.country = country;

      provinceToUpdate.countryId = country.id;

      countryChanged = true;

    }

    if (updateDto.latitude !== undefined) { provinceToUpdate.latitude = updateDto.latitude; coordsChanged = true; }

    if (updateDto.longitude !== undefined) { provinceToUpdate.longitude = updateDto.longitude; coordsChanged = true; }



    if (coordsChanged) {

        const existing = await this.provinceRepository.findOne({

            where: { latitude: provinceToUpdate.latitude, longitude: provinceToUpdate.longitude, id: Not(id) }

        });

        if (existing) throw new ConflictException(`Ubicación (lat/lon) ya registrada para otra provincia.`);

    }

    if ((nameChanged || countryChanged) && !coordsChanged) {

        const existing = await this.provinceRepository.findOne({

            where: { name: provinceToUpdate.name, countryId: provinceToUpdate.countryId, id: Not(id) }

        });

        if (existing) throw new ConflictException(`Provincia '${provinceToUpdate.name}' ya existe en el país.`);

    }

    // georefId eliminado



    const updated = await this.provinceRepository.save(provinceToUpdate);

    this.logger.log(`Provincia ID ${updated.id} actualizada (PATCH).`);

    return this.findOne(updated.id, true);

  }



  async remove(id: number): Promise<{ message: string }> {

    this.logger.debug(`Eliminando provincia ID: ${id}`);

    const province = await this.findOne(id, true);

    if (province.cities && province.cities.length > 0) {

      this.logger.warn(`No se puede eliminar provincia ID ${id}, tiene ciudades asociadas.`);

      throw new ConflictException(`No se puede eliminar provincia '${province.name}', tiene ciudades asociadas.`);

    }

    await this.provinceRepository.remove(province);

    this.logger.log(`Provincia ID: ${id} eliminada.`);

    return { message: `Provincia con ID ${id} eliminada correctamente.` };

  }

}

// src/city/city.service.ts

import { Injectable, NotFoundException, Logger, ConflictException, BadRequestException } from '@nestjs/common';

import { InjectRepository } from '@nestjs/typeorm';

import { Repository, ILike, Not, FindOptionsWhere } from 'typeorm'; // Importar FindOptionsWhere

import { City } from './entities/city.entity';

import { Province } from '../province/entities/province.entity';

import { CreateCityDto } from './dto/create-city.dto';

import { UpdateCityDto } from './dto/update-patch-city.dto';

import { UpdatePutCityDto } from './dto/update-put-city.dto';



@Injectable()

export class CitiesService {

  private readonly logger = new Logger(CitiesService.name);



  constructor(

    @InjectRepository(City)

    private readonly cityRepository: Repository<City>,

    @InjectRepository(Province)

    private readonly provinceRepository: Repository<Province>,

  ) {}



  private readonly defaultRelations = ['province', 'province.country'];



  private async findProvinceById(provinceId: number): Promise<Province> {

    this.logger.debug(`Buscando provincia ID: ${provinceId}`);

    const province = await this.provinceRepository.findOne({

        where: { id: provinceId },

        relations: ['country'],

      });

    if (!province) {

      this.logger.warn(`Provincia ID ${provinceId} no encontrada.`);

      throw new NotFoundException(`Provincia con ID ${provinceId} no encontrada.`);

    }

    return province;

  }



  async create(createCityDto: CreateCityDto): Promise<City> {

    this.logger.debug(`Intentando crear ciudad: ${createCityDto.name}, Lat: ${createCityDto.latitude}, Lon: ${createCityDto.longitude}`);

    const province = await this.findProvinceById(createCityDto.provinceId);



    const existingCityByCoords = await this.cityRepository.findOne({

      where: {

        latitude: createCityDto.latitude,

        longitude: createCityDto.longitude,

      }

    });



    if (existingCityByCoords) {

      this.logger.log(`Ciudad en Lat: ${createCityDto.latitude}, Lon: ${createCityDto.longitude} (Nombre: ${existingCityByCoords.name}) ya existe. Se omite creación y se retorna la existente.`);

      return this.findOne(existingCityByCoords.id, true);

    }



    const existingNominalCity = await this.cityRepository.findOne({

        where: { name: createCityDto.name, provinceId: createCityDto.provinceId }

    });

    if (existingNominalCity) {

        this.logger.warn(`Conflicto nominal: La ciudad '${createCityDto.name}' ya existe en la provincia '${province.name}' (pero con diferentes coordenadas).`);

        // throw new ConflictException(`Una ciudad llamada '${createCityDto.name}' ya existe en la provincia '${province.name}'.`);

    }



    const city = this.cityRepository.create({

      name: createCityDto.name,

      province: province,

      provinceId: province.id,

      latitude: createCityDto.latitude,

      longitude: createCityDto.longitude,

      // georefId: createCityDto.georefId || null, // georefId eliminado

    });



    try {

        const savedCity = await this.cityRepository.save(city);

        this.logger.log(`Ciudad creada ID: ${savedCity.id}, Nombre: ${savedCity.name}, Lat: ${savedCity.latitude}, Lon: ${savedCity.longitude}`);

        return this.findOne(savedCity.id, true);

    } catch (error: any) {

        if (error.code === '23505') {

            this.logger.warn(`Conflicto de BD al guardar ciudad: ${error.detail}. Intentando encontrarla...`);

            const raceConditionCity = await this.cityRepository.findOne({

                where: { latitude: createCityDto.latitude, longitude: createCityDto.longitude }

            });

            if (raceConditionCity) return this.findOne(raceConditionCity.id, true);

            throw new ConflictException(`La ubicación (lat/lon) para esta ciudad ya existe.`);

        }

        this.logger.error(`Error al guardar la ciudad: ${error.message}`, error.stack);

        throw error;

    }

  }



  async findAll(): Promise<City[]> {

    this.logger.debug('Buscando todas las ciudades');

    return this.cityRepository.find({ relations: this.defaultRelations });

  }



  async findOne(id: number, loadRelations: boolean = true): Promise<City> {

    this.logger.debug(`Buscando ciudad ID: ${id}`);

    const city = await this.cityRepository.findOne({

      where: { id },

      relations: loadRelations ? this.defaultRelations : ['province'],

    });

    if (!city) {

      this.logger.warn(`Ciudad ID ${id} no encontrada.`);

      throw new NotFoundException(`Ciudad con ID ${id} no encontrada.`);

    }

    return city;

  }



  async searchByName(term: string): Promise<City[]> {

    this.logger.debug(`Buscando ciudades por término: ${term}`);

    if (!term || term.trim() === "") {

      throw new BadRequestException('El término de búsqueda no puede estar vacío.');

    }

    const cities = await this.cityRepository.find({

      where: {

        name: ILike(`%${term}%`),

      },

      relations: this.defaultRelations,

    });

    this.logger.log(`Encontradas ${cities.length} ciudades para el término: ${term}`);

    return cities;

  }



  async findOneByNameAndProvinceName(cityName: string, provinceName: string): Promise<City | null> {

    this.logger.debug(`Buscando ciudad por nombre '${cityName}'${provinceName ? ` en provincia '${provinceName}'` : ''}`);

    

    const queryOptions: FindOptionsWhere<City> | FindOptionsWhere<City>[] = {

        name: cityName, // Búsqueda exacta por nombre de ciudad

    };



    if (provinceName) {

      // Si se proporciona provinceName, necesitamos hacer un join o una subconsulta.

      // La forma más directa con TypeORM es filtrar por la relación.

      return this.cityRepository.findOne({

        where: {

            name: cityName,

            province: { // Filtrar por el nombre de la provincia relacionada

                name: provinceName,

            }

        },

        relations: ['province'], // Cargar la provincia para asegurar el filtro y para la respuesta

      });

    } else {

      // Si no se proporciona provinceName, buscar solo por nombre de ciudad.

      // Esto podría devolver múltiples resultados si varias provincias tienen una ciudad con ese nombre.

      // findOne devolverá la primera que encuentre. Si necesitas manejar múltiples, usa find.

      const cities = await this.cityRepository.find({

        where: queryOptions,

        relations: ['province'], // Cargar provincia para dar más contexto

      });

      if (cities.length > 1) {

        this.logger.warn(`Múltiples ciudades encontradas con el nombre '${cityName}'. Se recomienda especificar la provincia.`);

        // Podrías lanzar un error aquí o devolver la primera. Por ahora, devolvemos la primera.

        return cities[0];

      }

      return cities.length > 0 ? cities[0] : null;

    }

  }





  async findOneByNameAndProvinceId(name: string, provinceId: number, loadRelations: boolean = false): Promise<City | null> {

    this.logger.debug(`Buscando ciudad por nombre '${name}' y provinceId '${provinceId}'`);

    const city = await this.cityRepository.findOne({

        where: {

            name: name,

            provinceId: provinceId

        },

        relations: loadRelations ? this.defaultRelations : ['province'],

    });



    if (!city) {

        this.logger.log(`Ciudad con nombre '${name}' y provinceId '${provinceId}' no encontrada.`);

        return null;

    }

    return city;

  }



  async updatePut(id: number, updateDto: UpdatePutCityDto): Promise<City> {

    this.logger.debug(`Actualizando (PUT) ciudad ID: ${id}`);

    const cityToUpdate = await this.findOne(id, false);

    const province = await this.findProvinceById(updateDto.provinceId);



    if (updateDto.latitude !== cityToUpdate.latitude || updateDto.longitude !== cityToUpdate.longitude) {

        const existingByCoords = await this.cityRepository.findOne({

            where: { latitude: updateDto.latitude, longitude: updateDto.longitude, id: Not(id) }

        });

        if (existingByCoords) {

            throw new ConflictException(`La ubicación (latitud/longitud) ya está registrada para otra ciudad.`);

        }

    }

    if (updateDto.name !== cityToUpdate.name || updateDto.provinceId !== cityToUpdate.provinceId) {

        const existingNominal = await this.cityRepository.findOne({

            where: { name: updateDto.name, provinceId: updateDto.provinceId, id: Not(id) }

        });

        if (existingNominal) {

            throw new ConflictException(`La combinación de nombre '${updateDto.name}' y provincia ya existe para otra ciudad.`);

        }

    }



    cityToUpdate.name = updateDto.name;

    cityToUpdate.province = province;

    cityToUpdate.provinceId = province.id;

    cityToUpdate.latitude = updateDto.latitude;

    cityToUpdate.longitude = updateDto.longitude;



    const updatedCity = await this.cityRepository.save(cityToUpdate);

    this.logger.log(`Ciudad ID ${updatedCity.id} actualizada (PUT).`);

    return this.findOne(updatedCity.id, true);

  }



  async updatePatch(id: number, updateDto: UpdateCityDto): Promise<City> {

    this.logger.debug(`Actualizando (PATCH) ciudad ID: ${id}`);

    const cityToUpdate = await this.cityRepository.findOne({ where: {id}, relations: ['province']});



    if (!cityToUpdate) {

      this.logger.warn(`Ciudad ID ${id} no encontrada para PATCH.`);

      throw new NotFoundException(`Ciudad con ID ${id} no encontrada.`);

    }



    let nameChanged = false;

    if (updateDto.name !== undefined && updateDto.name !== cityToUpdate.name) {

        cityToUpdate.name = updateDto.name;

        nameChanged = true;

    }

    let provinceChanged = false;

    if (updateDto.provinceId !== undefined && cityToUpdate.provinceId !== updateDto.provinceId) {

      const province = await this.findProvinceById(updateDto.provinceId);

      cityToUpdate.province = province;

      cityToUpdate.provinceId = province.id;

      provinceChanged = true;

    }

    let coordsChanged = false;

    if (updateDto.latitude !== undefined && updateDto.latitude !== cityToUpdate.latitude) {

        cityToUpdate.latitude = updateDto.latitude;

        coordsChanged = true;

    }

    if (updateDto.longitude !== undefined && updateDto.longitude !== cityToUpdate.longitude) {

        cityToUpdate.longitude = updateDto.longitude;

        coordsChanged = true;

    }



    if (coordsChanged) {

        const existingByCoords = await this.cityRepository.findOne({

            where: { latitude: cityToUpdate.latitude, longitude: cityToUpdate.longitude, id: Not(id) }

        });

        if (existingByCoords) {

            throw new ConflictException(`La ubicación (latitud/longitud) ya está registrada para otra ciudad.`);

        }

    }

    if ((nameChanged || provinceChanged) && !coordsChanged) {

        const existingNominal = await this.cityRepository.findOne({

            where: { name: cityToUpdate.name, provinceId: cityToUpdate.provinceId, id: Not(id) }

        });

        if (existingNominal) {

            throw new ConflictException(`La combinación de nombre '${cityToUpdate.name}' y provincia ya existe para otra ciudad.`);

        }

    }



    const updatedCity = await this.cityRepository.save(cityToUpdate);

    this.logger.log(`Ciudad ID ${updatedCity.id} actualizada (PATCH).`);

    return this.findOne(updatedCity.id, true);

  }



  async remove(id: number): Promise<{ message: string }> {

    this.logger.debug(`Eliminando ciudad ID: ${id}`);

    const city = await this.findOne(id, true);

    if (city.persons && city.persons.length > 0) {

        this.logger.warn(`No se puede eliminar la ciudad ID ${id} porque tiene personas asociadas.`);

        throw new ConflictException(`No se puede eliminar la ciudad '${city.name}' porque tiene personas asociadas. Reasigne las personas primero.`);

    }

    await this.cityRepository.remove(city);

    this.logger.log(`Ciudad ID: ${id} eliminada.`);

    return { message: `Ciudad con ID ${id} eliminada correctamente.` };

  }

}

// src/country/country.service.ts

import { Injectable, NotFoundException, ConflictException, Logger, BadRequestException } from '@nestjs/common';

import { InjectRepository } from '@nestjs/typeorm';

import { Repository, ILike, Not } from 'typeorm';

import { Country } from './entities/country.entity';

import { CreateCountryDto } from './dto/create-country.dto';

import { UpdateCountryDto } from './dto/update-patch-country.dto';

import { UpdatePutCountryDto } from './dto/update-put-country.dto';



@Injectable()

export class CountriesService {

  private readonly logger = new Logger(CountriesService.name);



  constructor(

    @InjectRepository(Country)

    private readonly countryRepository: Repository<Country>,

  ) {}



  private readonly defaultRelations = ['provinces'];



  async create(createCountryDto: CreateCountryDto): Promise<Country> {

    this.logger.debug(`Creando país: ${createCountryDto.name}`);

    const { name, code } = createCountryDto;



    const existingByName = await this.countryRepository.findOne({ where: { name } });

    if (existingByName) {

      this.logger.warn(`País con nombre '${name}' ya existe.`);

      throw new ConflictException(`País con nombre '${name}' ya existe.`);

    }

    if (code) {

      const existingByCode = await this.countryRepository.findOne({ where: { code } });

      if (existingByCode) {

        this.logger.warn(`País con código '${code}' ya existe.`);

        throw new ConflictException(`País con código '${code}' ya existe.`);

      }

    }



    const country = this.countryRepository.create({ name, code });

    const savedCountry = await this.countryRepository.save(country);

    this.logger.log(`País creado ID: ${savedCountry.id}`);

    return savedCountry; // Devolver la entidad sin cargar relaciones por defecto al crear

  }



  async findAll(loadRelations: boolean = false): Promise<Country[]> {

    this.logger.debug('Buscando todos los países');

    return this.countryRepository.find({ relations: loadRelations ? this.defaultRelations : [] });

  }



  async findOne(id: number, loadRelations: boolean = false): Promise<Country> {

    this.logger.debug(`Buscando país ID: ${id}`);

    const country = await this.countryRepository.findOne({

      where: { id },

      relations: loadRelations ? this.defaultRelations : [],

    });

    if (!country) {

      this.logger.warn(`País ID ${id} no encontrado.`);

      throw new NotFoundException(`País con ID ${id} no encontrado.`);

    }

    return country;

  }



  async findOneByName(name: string, loadRelations: boolean = false): Promise<Country | null> {

    this.logger.debug(`Buscando país por nombre: ${name}`);

    return this.countryRepository.findOne({

      where: { name },

      relations: loadRelations ? this.defaultRelations : [],

    });

  }



  async searchByName(term: string, loadRelations: boolean = false): Promise<Country[]> {

    this.logger.debug(`Buscando países por término: ${term}`);

    if (!term || term.trim() === "") {

      throw new BadRequestException('El término de búsqueda no puede estar vacío.');

    }

    return this.countryRepository.find({

      where: { name: ILike(`%${term}%`) },

      relations: loadRelations ? this.defaultRelations : [],

    });

  }



  async updatePut(id: number, updateDto: UpdatePutCountryDto): Promise<Country> {

    this.logger.debug(`Actualizando (PUT) país ID: ${id}`);

    const countryToUpdate = await this.findOne(id, false);

    const { name, code } = updateDto;



    if (name !== countryToUpdate.name) {

      const existing = await this.countryRepository.findOne({ where: { name, id: Not(id) } });

      if (existing) throw new ConflictException(`País con nombre '${name}' ya existe.`);

    }

    if (code && code !== countryToUpdate.code) {

      const existing = await this.countryRepository.findOne({ where: { code, id: Not(id) } });

      if (existing) throw new ConflictException(`País con código '${code}' ya existe.`);

    }



    countryToUpdate.name = name;

    countryToUpdate.code = code === undefined ? countryToUpdate.code : code;



    const updatedCountry = await this.countryRepository.save(countryToUpdate);

    this.logger.log(`País ID ${updatedCountry.id} actualizado (PUT).`);

    return updatedCountry;

  }



  async updatePatch(id: number, updateDto: UpdateCountryDto): Promise<Country> {

    this.logger.debug(`Actualizando (PATCH) país ID: ${id}`);

    const countryToUpdate = await this.countryRepository.preload({ id, ...updateDto });

    if (!countryToUpdate) {

      this.logger.warn(`País ID ${id} no encontrado para PATCH.`);

      throw new NotFoundException(`País con ID ${id} no encontrado.`);

    }



    if (updateDto.name && updateDto.name !== countryToUpdate.name) {

      const existing = await this.countryRepository.findOne({ where: { name: updateDto.name, id: Not(id) } });

      if (existing) throw new ConflictException(`País con nombre '${updateDto.name}' ya existe.`);

    }

    if (updateDto.code && updateDto.code !== countryToUpdate.code) {

      const existing = await this.countryRepository.findOne({ where: { code: updateDto.code, id: Not(id) } });

      if (existing) throw new ConflictException(`País con código '${updateDto.code}' ya existe.`);

    }



    const updatedCountry = await this.countryRepository.save(countryToUpdate);

    this.logger.log(`País ID ${updatedCountry.id} actualizado (PATCH).`);

    return updatedCountry;

  }



  async remove(id: number): Promise<{ message: string }> {

    this.logger.debug(`Eliminando país ID: ${id}`);

    const country = await this.findOne(id, true); // Cargar provincias para verificar

    if (country.provinces && country.provinces.length > 0) {

      this.logger.warn(`No se puede eliminar país ID ${id}, tiene provincias asociadas.`);

      throw new ConflictException(`No se puede eliminar el país '${country.name}' porque tiene provincias asociadas.`);

    }

    await this.countryRepository.remove(country);

    this.logger.log(`País ID: ${id} eliminado.`);

    return { message: `País con ID ${id} eliminado correctamente.` };

  }

}